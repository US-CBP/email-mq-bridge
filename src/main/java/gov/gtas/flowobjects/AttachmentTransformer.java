/*
 * All Application code is Copyright 2016, The Department of Homeland Security (DHS), U.S. Customs and Border Protection (CBP).
 *
 * Please see LICENSE.txt for details.
 */
package gov.gtas.flowobjects;

import lombok.Data;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.integration.annotation.Transformer;
import org.springframework.integration.support.MessageBuilder;
import org.springframework.messaging.Message;
import org.springframework.stereotype.Component;

import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Part;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

@Data
@Component
@PropertySource("classpath:application.yml")
public class AttachmentTransformer {

    @Value("${email.local.save}")
    Boolean SAVE_ATTACHMENTS_LOCALLY;

    @Value("${email.local.folder.attachments.saved}")
    String FOLDER_WHERE_ATTACHMENTS_ARE_SAVED;

    @Value("${email.local.maxFilenameLength}")
    Integer MAX_FILE_NAME_LENGTH;

    private Logger logger = LoggerFactory.getLogger(AttachmentTransformer.class);

    @Transformer
    public List<Message<?>> transform(MimeMessage payload) throws IOException, MessagingException {
        Map<String, String> attachmentMap = attachmentsAsStringWithFileNameAsKey(payload);
        return createMessages(attachmentMap);
    }

    private Map<String, String> attachmentsAsStringWithFileNameAsKey(MimeMessage payload) throws MessagingException, IOException {
        Map<String, String> attachmentAndName = new HashMap<>();
        Multipart multiPart = (Multipart) payload.getContent();
        for (int i = 0; i < multiPart.getCount(); i++) {
            MimeBodyPart part = (MimeBodyPart) multiPart.getBodyPart(i);
            if (Part.ATTACHMENT.equalsIgnoreCase(part.getDisposition())) {
                String fileName = getFileName(part);
                String attachmentAsString = IOUtils.toString(part.getInputStream(), StandardCharsets.UTF_8);
                attachmentAndName.put(fileName, attachmentAsString);
                if (SAVE_ATTACHMENTS_LOCALLY) {
                    saveFile(part, fileName);
                }
            }
        }
        return attachmentAndName;
    }

    private void saveFile(MimeBodyPart part, String fileName) throws MessagingException {
        String path = FOLDER_WHERE_ATTACHMENTS_ARE_SAVED + fileName.replaceAll("\\\\", "");
        try {
            part.saveFile(path);
            logger.info("Saved file to directory with path: " + path);
        } catch (IOException io) {
            logger.error("FAILED TO WRITE FILE TO PATH. IS SAVE FOLDER CORRECTLY SET?: " + path);
        }
    }

    private String getFileName(MimeBodyPart part) throws MessagingException {
        String fileName = "" + part.hashCode() + UUID.randomUUID() + part.getFileName();
        if (SAVE_ATTACHMENTS_LOCALLY &&
                FOLDER_WHERE_ATTACHMENTS_ARE_SAVED.length() + fileName.length() >= MAX_FILE_NAME_LENGTH) {
            fileName = fileName.substring(0, MAX_FILE_NAME_LENGTH);
        }
        return fileName;
    }

    private List<Message<?>> createMessages(Map<String, String> attachmentMap) {
        List<Message<?>> jmsMessages = new ArrayList<>();
        for (String attachmentName : attachmentMap.keySet()) {
            String payload = attachmentMap.get(attachmentName);
            Message message = MessageBuilder
                    .withPayload(payload)
                    .setHeader("filename", attachmentName)
                    .build();
            jmsMessages.add(message);
            logger.info("Created message for " + attachmentName);
        }
        return jmsMessages;
    }
}
